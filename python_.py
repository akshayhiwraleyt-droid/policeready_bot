import asyncio
import sqlite3
import json
import logging
import re
from datetime import datetime, date, timedelta
from typing import Dict, List, Tuple, Optional
import random

from telegram import (
    Update, 
    InlineKeyboardButton, 
    InlineKeyboardMarkup, 
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove
)
from telegram.ext import (
    Application, 
    CommandHandler, 
    ContextTypes, 
    ConversationHandler, 
    CallbackQueryHandler, 
    MessageHandler,
    filters,
    JobQueue
)
from telegram.constants import ParseMode

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Database setup
def init_database():
    conn = sqlite3.connect('maharashtra_police_bot.db')
    cursor = conn.cursor()
    
    # Create users table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        full_name TEXT,
        gender TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # Create user progress table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS user_progress (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        subject TEXT,
        score INTEGER,
        total_questions INTEGER,
        exam_date DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (user_id)
    )
    ''')
    
    # Create reminders table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS reminders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        reminder_text TEXT,
        reminder_time DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (user_id)
    )
    ''')
    
    conn.commit()
    conn.close()

# Initialize database
init_database()

# Define states for conversation
SELECTING_SUBJECT, EXAM_IN_PROGRESS, SETTING_REMINDER = range(3)

# Load questions from JSON file (you'll need to create this)
def load_questions():
    try:
        with open('questions.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        # Sample questions if file doesn't exist
        return {
            "рдорд░рд╛рдареА": [
                {
                    "question": "рдорд░рд╛рдареА рднрд╛рд╖реЗрддреАрд▓ рдкрд╣рд┐рд▓реЗ рдХрд╡реА рдХреЛрдг?",
                    "options": ["рд╕рдВрдд рдЬреНрдЮрд╛рдиреЗрд╢реНрд╡рд░", "рд╕рдВрдд рдПрдХрдирд╛рде", "рд╕рдВрдд рддреБрдХрд╛рд░рд╛рдо", "рд╕рдВрдд рдирд╛рдорджреЗрд╡"],
                    "correct_answer": 0
                }
            ],
            "рд╕рд╛рдорд╛рдиреНрдп рдЬреНрдЮрд╛рди": [
                {
                    "question": "рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░рд╛рдЪреА рд╕реНрдерд╛рдкрдирд╛ рдХрдзреА рдЭрд╛рд▓реА?",
                    "options": ["рез рдореЗ резрепремреж", "резрел рдСрдЧрд╕реНрдЯ резрепрекрен", "реирем рдЬрд╛рдиреЗрд╡рд╛рд░реА резрепрелреж", "рез рдиреЛрд╡реНрд╣реЗрдВрдмрд░ резрепрелрем"],
                    "correct_answer": 0
                }
            ],
            "рдмреБрджреНрдзрд┐рдорддреНрддрд╛ рдЪрд╛рдЪрдгреА": [
                {
                    "question": "рдЬрд░ A = 1, B = 2, рддрд░ Z = ?",
                    "options": ["24", "25", "26", "27"],
                    "correct_answer": 2
                }
            ],
            "рдЧрдгрд┐рдд": [
                {
                    "question": "реирел рдЪреЗ рд╡рд░реНрдЧрдореВрд│ рдХрд┐рддреА?",
                    "options": ["5", "6", "7", "8"],
                    "correct_answer": 0
                }
            ],
            "рдЗрддрд┐рд╣рд╛рд╕/рднреВрдЧреЛрд▓/рд╕рдВрд╡рд┐рдзрд╛рди": [
                {
                    "question": "рднрд╛рд░рддрд╛рдЪреЗ рд░рд╛рд╖реНрдЯреНрд░реАрдп рдЪрд┐рдиреНрд╣ рдХреЛрдареВрди рдШреЗрдгреНрдпрд╛рдд рдЖрд▓реЗ рдЖрд╣реЗ?",
                    "options": ["рдореБрдШрд▓ рд╕рд╛рдореНрд░рд╛рдЬреНрдп", "рдЕрд╢реЛрдХ рд╕реНрддрдВрдн", "рдорд╣рд╛рдмрд│реЗрд╢реНрд╡рд░", "рд╣рд╕реНрддрд▓рд┐рдЦрд┐рдд рд╕рдВрд╡рд┐рдзрд╛рди"],
                    "correct_answer": 1
                }
            ],
            "рдЪрд╛рд▓реВ рдШрдбрд╛рдореЛрдбреА": [
                {
                    "question": "рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░рд╛рдЪреЗ рд╕рдзреНрдпрд╛рдЪреЗ рдореБрдЦреНрдпрдордВрддреНрд░реА рдХреЛрдг?",
                    "options": ["рдПрдХрдирд╛рде рд╢рд┐рдВрджреЗ", "рджреЗрд╡реЗрдВрджреНрд░ рдлрдбрдгрд╡реАрд╕", "рдЙрджреНрдзрд╡ рдард╛рдХрд░реЗ", "рдЕрдЬрд┐рдд рдкрд╡рд╛рд░"],
                    "correct_answer": 0
                }
            ]
        }

# Load questions
questions_data = load_questions()

# Load daily thoughts
daily_thoughts = [
    {
        "thought": "рдЬрд┐рдВрдХрдгреНрдпрд╛рдЪреА рдЗрдЪреНрдЫрд╛ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ рдорд╛рдгрд╕рд╛рд▓рд╛ рдХреЛрдгреАрд╣реА рдкрд░рд╛рднреВрдд рдХрд░реВ рд╢рдХрдд рдирд╛рд╣реА.",
        "author": "рдЫрддреНрд░рдкрддреА рд╢рд┐рд╡рд╛рдЬреА рдорд╣рд╛рд░рд╛рдЬ"
    },
    {
        "thought": "рд╢рд┐рдХреНрд╖рдг рд╣реЗ рд╕рдорд╛рдЬрд╛рдЪреЗ рдЖрдзрд╛рд░рд╕реНрддрдВрдн рдЖрд╣реЗрдд рдЖрдгрд┐ рддреЗ рд╕рдорд╛рдЬрд╛рддреАрд▓ рдкреНрд░рддреНрдпреЗрдХ рд╡реНрдпрдХреНрддреАрдкрд░реНрдпрдВрдд рдкреЛрд╣реЛрдЪрд▓реЗ рдкрд╛рд╣рд┐рдЬреЗ.",
        "author": "рдбреЙ. рдмрд╛рдмрд╛рд╕рд╛рд╣реЗрдм рдЖрдВрдмреЗрдбрдХрд░"
    },
    {
        "thought": "рд╕реНрд╡рд╛рддрдВрддреНрд░реНрдп рд╣рд╛ рдЖрдкрд▓рд╛ рдЬрдиреНрдорд╕рд┐рджреНрдз рд╣рдХреНрдХ рдЖрд╣реЗ рдЖрдгрд┐ рдЖрдкрдг рддреЛ рдорд┐рд│рд╡рдгрд╛рд░рдЪ.",
        "author": "рд▓реЛрдХрдорд╛рдиреНрдп рдЯрд┐рд│рдХ"
    },
    {
        "thought": "рдХрд╖реНрдЯрд╛рдЪреЗ рдлрд│ рдЧреЛрдб рдЕрд╕рддреЗ, рддреЗ рдорд┐рд│рд╡рдгреНрдпрд╛рд╕рд╛рдареА рдХрд╖реНрдЯ рдХрд░рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ.",
        "author": "рд▓рд╛рд▓рдмрд╣рд╛рджреВрд░ рд╢рд╛рд╕реНрддреНрд░реА"
    }
]

# News updates (would typically come from an API)
news_updates = [
    "рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░ рдкреЛрд▓рд┐рд╕ рднрд░рддреА реирежреирей: релрежрежреж рдЬрд╛рдЧрд╛рдВрд╕рд╛рдареА рдЕрдзрд┐рд╕реВрдЪрдирд╛ рдЬрд╛рд░реА",
    "рдкреЛрд▓рд┐рд╕ рднрд░рддреА рдкрд░реАрдХреНрд╖реЗрдЪреНрдпрд╛ рддрдпрд╛рд░реАрд╕рд╛рдареА рдорд╛рд░реНрдЧрджрд░реНрд╢рдХ рдХрд╛рд░реНрдпрд╢рд╛рд│рд╛ рдЖрдпреЛрдЬрд┐рдд",
    "рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░ рд╕рд░рдХрд╛рд░рдордзреНрдпреЗ рдирд╡реАрди рдкреЛрд▓рд┐рд╕ рднрд░рддреА рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд╕реБрд░реВ",
    "рдкреЛрд▓рд┐рд╕ рднрд░рддреАрд╕рд╛рдареА рдСрдирд▓рд╛рдЗрди рдЕрд░реНрдЬ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд╕реБрд░реВ"
]

# Gender detection based on name endings (basic estimation for Marathi names)
def detect_gender(name):
    name = name.lower().strip()
    female_endings = ['рд╛', 'реА', 'реАрдд', 'рд┐рди', 'рд┐рдпрд╛', 'рдирд╛', 'рддрд╛', 'рд▓рд╛', 'рдорд╛', 'рд╡реА']
    male_endings = ['реЗ', 'рдп', 'рдХ', 'рд░', 'рд╕', 'рдд', 'рди', 'рдк', 'рдЬ', 'рд╡']
    
    for ending in female_endings:
        if name.endswith(ending):
            return "рд╕реНрддреНрд░реА"
    
    for ending in male_endings:
        if name.endswith(ending):
            return "рдкреБрд░реБрд╖"
    
    return "рдЕрдиреНрдп"

# Main menu keyboard
def main_menu_keyboard():
    keyboard = [
        ["ЁЯУЭ рдкрд░реАрдХреНрд╖рд╛ рд╕реБрд░реВ рдХрд░рд╛", "ЁЯУШ рд╡рд┐рд╖рдп рдирд┐рд╡рдбрд╛"],
        ["ЁЯТб рджреИрдирдВрджрд┐рди рд╡рд┐рдЪрд╛рд░", "ЁЯУ░ рдмрд╛рддрдореНрдпрд╛"],
        ["тП░ рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХрд░рд╛", "ЁЯХТ рд╡реЗрд│ рдЖрдгрд┐ рддрд╛рд░реАрдЦ"]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

# Subject selection keyboard
def subject_keyboard():
    keyboard = [
        [
            InlineKeyboardButton("ЁЯУШ рдорд░рд╛рдареА", callback_data="subject_рдорд░рд╛рдареА"),
            InlineKeyboardButton("ЁЯУЩ рд╕рд╛рдорд╛рдиреНрдп рдЬреНрдЮрд╛рди", callback_data="subject_рд╕рд╛рдорд╛рдиреНрдп рдЬреНрдЮрд╛рди")
        ],
        [
            InlineKeyboardButton("ЁЯУЧ рдмреБрджреНрдзрд┐рдорддреНрддрд╛ рдЪрд╛рдЪрдгреА", callback_data="subject_рдмреБрджреНрдзрд┐рдорддреНрддрд╛ рдЪрд╛рдЪрдгреА"),
            InlineKeyboardButton("ЁЯУХ рдЧрдгрд┐рдд", callback_data="subject_рдЧрдгрд┐рдд")
        ],
        [
            InlineKeyboardButton("ЁЯУЪ рдЗрддрд┐рд╣рд╛рд╕/рднреВрдЧреЛрд▓/рд╕рдВрд╡рд┐рдзрд╛рди", callback_data="subject_рдЗрддрд┐рд╣рд╛рд╕/рднреВрдЧреЛрд▓/рд╕рдВрд╡рд┐рдзрд╛рди"),
            InlineKeyboardButton("ЁЯУ░ рдЪрд╛рд▓реВ рдШрдбрд╛рдореЛрдбреА", callback_data="subject_рдЪрд╛рд▓реВ рдШрдбрд╛рдореЛрдбреА")
        ],
        [
            InlineKeyboardButton("ЁЯФЩ рдореБрдЦреНрдп рдореЗрдиреВ", callback_data="main_menu")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

# District selection keyboard (for future enhancement)
def district_keyboard():
    keyboard = [
        [
            InlineKeyboardButton("рдЬрд╛рд▓рдирд╛", callback_data="district_рдЬрд╛рд▓рдирд╛"),
            InlineKeyboardButton("рдФрд░рдВрдЧрд╛рдмрд╛рдж", callback_data="district_рдФрд░рдВрдЧрд╛рдмрд╛рдж")
        ],
        [
            InlineKeyboardButton("рдореБрдВрдмрдИ", callback_data="district_рдореБрдВрдмрдИ"),
            InlineKeyboardButton("рдкреБрдгреЗ", callback_data="district_рдкреБрдгреЗ")
        ],
        [
            InlineKeyboardButton("ЁЯФЩ рдореБрдЦреНрдп рдореЗрдиреВ", callback_data="main_menu")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

# Start command
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    context.user_data['user_id'] = user.id
    
    # Check if user exists in database
    conn = sqlite3.connect('maharashtra_police_bot.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE user_id = ?", (user.id,))
    existing_user = cursor.fetchone()
    
    if not existing_user:
        # Ask for user's name
        await update.message.reply_text(
            "рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░ рдкреЛрд▓рд┐рд╕ рднрд░рддреА рдмреЙрдЯрдордзреНрдпреЗ рдЖрдкрд▓реЗ рд╕реНрд╡рд╛рдЧрдд рдЖрд╣реЗ! ЁЯСотАНтЩВя╕П\n\n"
            "рдХреГрдкрдпрд╛ рдЖрдкрд▓реЗ рдирд╛рд╡ рдкреНрд░рд╡рд┐рд╖реНрдЯ рдХрд░рд╛:",
            reply_markup=ReplyKeyboardRemove()
        )
        return 0
    else:
        await update.message.reply_text(
            f"рдкреБрдиреНрд╣рд╛ рднреЗрдЯрд▓реНрдпрд╛рд╡рд░ рдЖрдирдВрдж рдЭрд╛рд▓рд╛ {existing_user[2]}! ЁЯШК\n\n"
            "рдореБрдЦреНрдп рдореЗрдиреВ:",
            reply_markup=main_menu_keyboard()
        )
        return ConversationHandler.END

# Get user's name and detect gender
async def get_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_name = update.message.text
    gender = detect_gender(user_name)
    
    # Store user data
    user = update.effective_user
    conn = sqlite3.connect('maharashtra_police_bot.db')
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO users (user_id, username, full_name, gender) VALUES (?, ?, ?, ?)",
        (user.id, user.username, user_name, gender)
    )
    conn.commit()
    conn.close()
    
    # Greet based on gender
    if gender == "рд╕реНрддреНрд░реА":
        greeting = f"рд╕реБрд╕реНрд╡рд╛рдЧрддрдо {user_name}! рддреБрдордЪреНрдпрд╛ рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░ рдкреЛрд▓рд┐рд╕ рднрд░рддреА рддрдпрд╛рд░реАрдЪреНрдпрд╛ рд╕рдлрд░реЗрдд рдЖрдореНрд╣реА рддреБрдордЪреНрдпрд╛ рд╕реЛрдмрдд рдЖрд╣реЛрдд! ЁЯСотАНтЩАя╕П"
    elif gender == "рдкреБрд░реБрд╖":
        greeting = f"рд╕реБрд╕реНрд╡рд╛рдЧрддрдо {user_name}! рддреБрдордЪреНрдпрд╛ рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░ рдкреЛрд▓рд┐рд╕ рднрд░рддреА рддрдпрд╛рд░реАрдЪреНрдпрд╛ рд╕рдлрд░реЗрдд рдЖрдореНрд╣реА рддреБрдордЪреНрдпрд╛ рд╕реЛрдмрдд рдЖрд╣реЛрдд! ЁЯСотАНтЩВя╕П"
    else:
        greeting = f"рд╕реБрд╕реНрд╡рд╛рдЧрддрдо {user_name}! рддреБрдордЪреНрдпрд╛ рдорд╣рд╛рд░рд╛рд╖реНрдЯреНрд░ рдкреЛрд▓рд┐рд╕ рднрд░рддреА рддрдпрд╛рд░реАрдЪреНрдпрд╛ рд╕рдлрд░реЗрдд рдЖрдореНрд╣реА рддреБрдордЪреНрдпрд╛ рд╕реЛрдмрдд рдЖрд╣реЛрдд! ЁЯСо"
    
    await update.message.reply_text(
        greeting + "\n\nрдореБрдЦреНрдп рдореЗрдиреВ:",
        reply_markup=main_menu_keyboard()
    )
    return ConversationHandler.END

# Main menu handler
async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "рдореБрдЦреНрдп рдореЗрдиреВ:",
        reply_markup=main_menu_keyboard()
    )

# Start exam
async def start_exam(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Check if user has selected a subject
    if 'current_subject' not in context.user_data:
        await update.message.reply_text(
            "рдХреГрдкрдпрд╛ рдкреНрд░рдердо рд╡рд┐рд╖рдп рдирд┐рд╡рдбрд╛:",
            reply_markup=subject_keyboard()
        )
        return SELECTING_SUBJECT
    
    # Start the exam
    subject = context.user_data['current_subject']
    context.user_data['current_question'] = 0
    context.user_data['score'] = 0
    context.user_data['correct_streak'] = 0
    
    # Load questions for the subject
    if subject in questions_data:
        context.user_data['questions'] = questions_data[subject]
        total_questions = len(context.user_data['questions'])
        context.user_data['total_questions'] = total_questions
        
        # Set exam timer (60 minutes for 100 questions)
        exam_duration = 3600  # 60 minutes in seconds
        context.user_data['exam_end_time'] = datetime.now() + timedelta(seconds=exam_duration)
        
        # Start the exam
        await display_question(update, context)
        
        # Schedule timer updates
        context.job_queue.run_repeating(
            update_exam_timer, 
            interval=10, 
            first=10, 
            chat_id=update.effective_chat.id, 
            name=str(update.effective_chat.id)
        )
        
        # Schedule 10-minute warning
        warning_time = exam_duration - 600  # 10 minutes before end
        if warning_time > 0:
            context.job_queue.run_once(
                warn_remaining_time, 
                warning_time, 
                chat_id=update.effective_chat.id, 
                name=f"warning_{update.effective_chat.id}"
            )
        
        return EXAM_IN_PROGRESS
    else:
        await update.message.reply_text(
            "рдХреНрд╖рдорд╕реНрд╡, рдпрд╛ рд╡рд┐рд╖рдпрд╛рд╕рд╛рдареА рдкреНрд░рд╢реНрди рдЙрдкрд▓рдмреНрдз рдирд╛рд╣реАрдд. рдХреГрдкрдпрд╛ рджреБрд╕рд░рд╛ рд╡рд┐рд╖рдп рдирд┐рд╡рдбрд╛.",
            reply_markup=subject_keyboard()
        )
        return SELECTING_SUBJECT

# Display current question
async def display_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    question_index = context.user_data['current_question']
    questions = context.user_data['questions']
    
    if question_index < len(questions):
        question_data = questions[question_index]
        question_text = question_data['question']
        options = question_data['options']
        
        # Create inline keyboard for options
        keyboard = []
        for i, option in enumerate(options):
            keyboard.append([InlineKeyboardButton(f"{i+1}. {option}", callback_data=f"answer_{i}")])
        
        # Add exit button
        keyboard.append([InlineKeyboardButton("ЁЯЪк рдкрд░реАрдХреНрд╖рд╛ рд╕реЛрдбрд╛", callback_data="exit_exam")])
        
        # Display question with timer
        remaining_time = context.user_data['exam_end_time'] - datetime.now()
        minutes, seconds = divmod(int(remaining_time.total_seconds()), 60)
        
        message = (
            f"тП░ рдЙрд░реНрд╡рд░рд┐рдд рд╡реЗрд│: {minutes:02d}:{seconds:02d}\n\n"
            f"рдкреНрд░рд╢реНрди {question_index + 1}/{len(questions)}:\n"
            f"{question_text}\n\n"
            "рдкрд░реНрдпрд╛рдп:"
        )
        
        if update.callback_query:
            await update.callback_query.edit_message_text(
                message, 
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                message, 
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
    else:
        # Exam finished
        await finish_exam(update, context)

# Update exam timer
async def update_exam_timer(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    chat_id = job.chat_id
    
    if 'exam_end_time' in context.user_data:
        remaining_time = context.user_data['exam_end_time'] - datetime.now()
        if remaining_time.total_seconds() <= 0:
            # Exam time is over
            await context.bot.send_message(
                chat_id=chat_id,
                text="тП░ рдкрд░реАрдХреНрд╖реЗрдЪрд╛ рд╡реЗрд│ рд╕рдВрдкрд▓рд╛ рдЖрд╣реЗ!",
                reply_markup=main_menu_keyboard()
            )
            job.schedule_removal()
            return ConversationHandler.END
        
        minutes, seconds = divmod(int(remaining_time.total_seconds()), 60)
        
        # Update the message with remaining time
        try:
            await context.bot.edit_message_text(
                text=f"тП░ рдЙрд░реНрд╡рд░рд┐рдд рд╡реЗрд│: {minutes:02d}:{seconds:02d}",
                chat_id=chat_id,
                message_id=context.user_data.get('timer_message_id')
            )
        except:
            # Message might not be accessible, ignore error
            pass

# Warn about remaining time
async def warn_remaining_time(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    chat_id = job.chat_id
    
    # Send warning message
    warning_msg = await context.bot.send_message(
        chat_id=chat_id,
        text="тЪая╕П рд╕рд╛рд╡рдзрд╛рди! рдкрд░реАрдХреНрд╖реЗрдЪрд╛ рд╡реЗрд│ рдлрдХреНрдд резреж рдорд┐рдирд┐рдЯреЗ рд╢рд┐рд▓реНрд▓рдХ рдЖрд╣реЗ! тЪая╕П",
        parse_mode=ParseMode.HTML
    )
    
    # Blink the warning message
    for _ in range(5):
        await asyncio.sleep(1)
        try:
            await context.bot.edit_message_text(
                text="<b>тЪая╕П рд╕рд╛рд╡рдзрд╛рди! рдкрд░реАрдХреНрд╖реЗрдЪрд╛ рд╡реЗрд│ рдлрдХреНрдд резреж рдорд┐рдирд┐рдЯреЗ рд╢рд┐рд▓реНрд▓рдХ рдЖрд╣реЗ! тЪая╕П</b>",
                chat_id=chat_id,
                message_id=warning_msg.message_id,
                parse_mode=ParseMode.HTML
            )
        except:
            pass
        
        await asyncio.sleep(1)
        try:
            await context.bot.edit_message_text(
                text="тЪая╕П рд╕рд╛рд╡рдзрд╛рди! рдкрд░реАрдХреНрд╖реЗрдЪрд╛ рд╡реЗрд│ рдлрдХреНрдд резреж рдорд┐рдирд┐рдЯреЗ рд╢рд┐рд▓реНрд▓рдХ рдЖрд╣реЗ! тЪая╕П",
                chat_id=chat_id,
                message_id=warning_msg.message_id,
                parse_mode=ParseMode.HTML
            )
        except:
            pass

# Handle answer selection
async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    answer_index = int(query.data.split('_')[1])
    question_index = context.user_data['current_question']
    questions = context.user_data['questions']
    question_data = questions[question_index]
    correct_index = question_data['correct_answer']
    
    # Check if answer is correct
    if answer_index == correct_index:
        context.user_data['score'] += 1
        context.user_data['correct_streak'] += 1
        
        # Celebration for every 10 correct answers
        if context.user_data['correct_streak'] % 10 == 0:
            celebration_messages = [
                "рдЕрднрд┐рдирдВрджрди! ЁЯФе рддреБрдордЪреА рдХрд╛рдордЧрд┐рд░реА рдЕрддреНрдпрдВрдд рдЙрддреНрдХреГрд╖реНрдЯ рдЖрд╣реЗ!",
                "рд╡рд╛рд╣! ЁЯМЯ рддреБрдореНрд╣реА рдЕрдкреНрд░рддрд┐рдо рдкреНрд░рдЧрддреА рдХрд░рдд рдЖрд╣рд╛рдд!",
                "рдЕрджреНрднреБрдд! ЁЯТп рддреБрдордЪреНрдпрд╛ рдХрд╖реНрдЯрд╛рдЪреЗ рдлрд│ рдорд┐рд│рдд рдЖрд╣реЗ!"
            ]
            await query.edit_message_text(
                text=f"тЬЕ рдмрд░реЛрдмрд░ рдЙрддреНрддрд░!\n\n{random.choice(celebration_messages)}"
            )
            await asyncio.sleep(2)
        else:
            # Show correct answer animation
            await query.edit_message_text(
                text="тЬЕ рдмрд░реЛрдмрд░ рдЙрддреНрддрд░! " + "ЁЯОЙ" * min(context.user_data['correct_streak'], 5)
            )
            await asyncio.sleep(1)
    else:
        context.user_data['correct_streak'] = 0
        correct_answer = question_data['options'][correct_index]
        
        # Show wrong answer animation
        await query.edit_message_text(
            text=f"тЭМ рдЪреБрдХреАрдЪреЗ рдЙрддреНрддрд░!\n\nрдпреЛрдЧреНрдп рдЙрддреНрддрд░: {correct_answer}"
        )
        await asyncio.sleep(2)
    
    # Move to next question
    context.user_data['current_question'] += 1
    await display_question(update, context)

# Finish exam and show results
async def finish_exam(update: Update, context: ContextTypes.DEFAULT_TYPE):
    score = context.user_data['score']
    total_questions = context.user_data['total_questions']
    subject = context.user_data['current_subject']
    
    # Calculate percentage
    percentage = (score / total_questions) * 100
    
    # Store result in database
    user_id = context.user_data['user_id']
    conn = sqlite3.connect('maharashtra_police_bot.db')
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO user_progress (user_id, subject, score, total_questions) VALUES (?, ?, ?, ?)",
        (user_id, subject, score, total_questions)
    )
    conn.commit()
    conn.close()
    
    # Prepare result message
    result_message = (
        f"ЁЯУК рддреБрдордЪреЗ рдкрд░реАрдХреНрд╖рд╛ рдирд┐рдХрд╛рд▓:\n\n"
        f"рд╡рд┐рд╖рдп: {subject}\n"
        f"рдПрдХреВрдг рдкреНрд░рд╢реНрди: {total_questions}\n"
        f"рдмрд░реЛрдмрд░ рдЙрддреНрддрд░реЗ: {score}\n"
        f"рдЯрдХреНрдХреЗрд╡рд╛рд░реА: {percentage:.2f}%\n\n"
    )
    
    # Add motivational message based on score
    if percentage < 50:
        result_message += (
            "ЁЯТк рдШрд╛рдмрд░реВ рдирдХрд╛! рдХрд╖реНрдЯ рд╕реБрд░реВ рдареЗрд╡рд╛, рдХреБрдЯреБрдВрдм рдЖрдгрд┐ рдорд┐рддреНрд░рд╛рдВрдЪреНрдпрд╛ рд╕рд╣рдХрд╛рд░реНрдпрд╛рдиреЗ рддреБрдореНрд╣реА рдирдХреНрдХреАрдЪ рдпрд╢рд╕реНрд╡реА рд╡реНрд╣рд╛рд▓!\n\n"
            "ЁЯУЪ рдЕрдзрд┐рдХ рд╕рд░рд╛рд╡ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛!"
        )
    else:
        result_message += (
            "ЁЯОЦя╕П рдЕрднрд┐рдирдВрджрди! рдЙрддреНрддрдо рдХрд╛рдордЧрд┐рд░реА!\n\n"
            "рд╡рд░реНрджреА рддреБрдЭреА рд╡рд╛рдЯ рдкрд╛рд╣рдд рдЖрд╣реЗ! ЁЯСотАНтЩВя╕П"
        )
    
    # Send result message
    if update.callback_query:
        await update.callback_query.edit_message_text(
            result_message,
            reply_markup=main_menu_keyboard()
        )
    else:
        await update.message.reply_text(
            result_message,
            reply_markup=main_menu_keyboard()
        )
    
    # Remove exam timer job
    if 'exam_timer_job' in context.user_data:
        context.user_data['exam_timer_job'].schedule_removal()
    
    return ConversationHandler.END

# Exit exam
async def exit_exam(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    # Confirm exit
    keyboard = [
        [InlineKeyboardButton("тЬЕ рд╣реЛрдп", callback_data="confirm_exit")],
        [InlineKeyboardButton("тЭМ рдирд╛рд╣реА", callback_data="cancel_exit")]
    ]
    
    await query.edit_message_text(
        "рддреБрдореНрд╣рд╛рд▓рд╛ рдкрд░реАрдХреНрд╖рд╛ рд╕реЛрдбрд╛рдпрдЪреА рдЖрд╣реЗ рдХрд╛? рд╕рдзреНрдпрд╛ рдХреЗрд▓реЗрд▓реЗ рдкреНрд░рдЧрддреА рдирд╖реНрдЯ рд╣реЛрдИрд▓.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

# Confirm exam exit
async def confirm_exit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "рдкрд░реАрдХреНрд╖рд╛ рд╕реЛрдбрд▓реА рдЖрд╣реЗ. рдореБрдЦреНрдп рдореЗрдиреВрдордзреНрдпреЗ рдкрд░рдд рдЖрд▓рд╛рдд.",
        reply_markup=main_menu_keyboard()
    )
    
    # Remove exam timer job
    if 'exam_timer_job' in context.user_data:
        context.user_data['exam_timer_job'].schedule_removal()
    
    return ConversationHandler.END

# Cancel exam exit
async def cancel_exit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    # Return to current question
    await display_question(update, context)
    return EXAM_IN_PROGRESS

# Select subject
async def select_subject(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data.startswith("subject_"):
        subject = query.data.split("_")[1]
        context.user_data['current_subject'] = subject
        
        await query.edit_message_text(
            f"рддреБрдореНрд╣реА рдирд┐рд╡рдбрд▓реЗрд▓рд╛ рд╡рд┐рд╖рдп: {subject}\n\n"
            "рдкрд░реАрдХреНрд╖рд╛ рд╕реБрд░реВ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА 'ЁЯУЭ рдкрд░реАрдХреНрд╖рд╛ рд╕реБрд░реВ рдХрд░рд╛' рд╡рд░ рдХреНрд▓рд┐рдХ рдХрд░рд╛.",
            reply_markup=main_menu_keyboard()
        )
    elif query.data == "main_menu":
        await query.edit_message_text(
            "рдореБрдЦреНрдп рдореЗрдиреВ:",
            reply_markup=main_menu_keyboard()
        )
    
    return ConversationHandler.END

# Show daily thought
async def daily_thought(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Get today's thought (based on day of year for consistency)
    day_of_year = datetime.now().timetuple().tm_yday
    thought_index = day_of_year % len(daily_thoughts)
    thought = daily_thoughts[thought_index]
    
    await update.message.reply_text(
        f"ЁЯУЕ рджреИрдирдВрджрд┐рди рд╡рд┐рдЪрд╛рд░:\n\n"
        f"{thought['thought']}\n\n"
        f"- {thought['author']}"
    )

# Show news updates
async def news_updates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Get today's news (in a real scenario, this would come from an API)
    today_news = news_updates[datetime.now().day % len(news_updates)]
    
    await update.message.reply_text(
        f"ЁЯУ░ рдЕрджреНрдпрддрди рдмрд╛рддрдореНрдпрд╛:\n\n"
        f"{today_news}\n\n"
        f"ЁЯУЕ {datetime.now().strftime('%d-%m-%Y')}"
    )

# Set reminder
async def set_reminder(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "тП░ рддреБрдореНрд╣рд╛рд▓рд╛ рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХрд░рд╛рдпрдЪрд╛ рдЖрд╣реЗ рдХрд╛?\n\n"
        "рдХреГрдкрдпрд╛ рд░рд┐рдорд╛рдЗрдВрдбрд░рдЪрд╛ рд╕рдВрджреЗрд╢ рдЖрдгрд┐ рд╡реЗрд│ рдкрд╛рдард╡рд╛ (рдЙрджрд╛: 'рдЙрджреНрдпрд╛ рд╕рдХрд╛рд│реА реп рд╡рд╛рдЬрддрд╛ рдЕрднреНрдпрд╛рд╕ рд╕реБрд░реВ рдХрд░рд╛').",
        reply_markup=ReplyKeyboardRemove()
    )
    return SETTING_REMINDER

# Handle reminder input
async def handle_reminder_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    reminder_text = update.message.text
    user_id = context.user_data['user_id']
    
    # Simple reminder parsing (in a real scenario, use a proper NLP library)
    if 'рдЙрджреНрдпрд╛' in reminder_text:
        reminder_time = datetime.now() + timedelta(days=1)
    elif 'рдЖрдЬ' in reminder_text:
        reminder_time = datetime.now()
    else:
        reminder_time = datetime.now() + timedelta(hours=1)
    
    # Set time to 9 AM if not specified
    reminder_time = reminder_time.replace(hour=9, minute=0, second=0, microsecond=0)
    
    # Store reminder in database
    conn = sqlite3.connect('maharashtra_police_bot.db')
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO reminders (user_id, reminder_text, reminder_time) VALUES (?, ?, ?)",
        (user_id, reminder_text, reminder_time)
    )
    conn.commit()
    conn.close()
    
    # Schedule reminder
    context.job_queue.run_once(
        send_reminder, 
        when=reminder_time, 
        chat_id=update.effective_chat.id, 
        data=reminder_text,
        name=f"reminder_{user_id}_{reminder_time}"
    )
    
    await update.message.reply_text(
        f"тЬЕ рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХреЗрд▓рд╛ рдЖрд╣реЗ!\n\n"
        f"рд╕рдВрджреЗрд╢: {reminder_text}\n"
        f"рд╡реЗрд│: {reminder_time.strftime('%d-%m-%Y %H:%M')}",
        reply_markup=main_menu_keyboard()
    )
    
    return ConversationHandler.END

# Send reminder
async def send_reminder(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    await context.bot.send_message(
        chat_id=job.chat_id,
        text=f"тП░ рд░рд┐рдорд╛рдЗрдВрдбрд░:\n\n{job.data}"
    )

# Show current time and date
async def show_time_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    now = datetime.now()
    await update.message.reply_text(
        f"ЁЯХТ рд╡реЗрд│ рдЖрдгрд┐ рддрд╛рд░реАрдЦ:\n\n"
        f"рддрд╛рд░реАрдЦ: {now.strftime('%d-%m-%Y')}\n"
        f"рд╡реЗрд│: {now.strftime('%H:%M:%S')}\n"
        f"рд╡рд╛рд░: {['рд╕реЛрдорд╡рд╛рд░', 'рдордВрдЧрд│рд╡рд╛рд░', 'рдмреБрдзрд╡рд╛рд░', 'рдЧреБрд░реБрд╡рд╛рд░', 'рд╢реБрдХреНрд░рд╡рд╛рд░', 'рд╢рдирд┐рд╡рд╛рд░', 'рд░рд╡рд┐рд╡рд╛рд░'][now.weekday()]}"
    )

# Cancel conversation
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "рдСрдкрд░реЗрд╢рди рд░рджреНрдж рдХреЗрд▓реЗ рдЖрд╣реЗ.",
        reply_markup=main_menu_keyboard()
    )
    return ConversationHandler.END

# Error handler
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(msg="Exception while handling an update:", exc_info=context.error)
    
    # Send a message to the user
    await update.message.reply_text(
        "рдХреНрд╖рдорд╕реНрд╡, рддрд╛рдВрддреНрд░рд┐рдХ рд╕рдорд╕реНрдпрд╛ рдЖрд▓реА рдЖрд╣реЗ. рдХреГрдкрдпрд╛ рдирдВрддрд░ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛.",
        reply_markup=main_menu_keyboard()
    )

# Main function
def main():
    # Create Application
    application = Application.builder().token("8034142571:AAFEUhf8UEPz0lE6p60wPwcIHzAN09OPjuQ").build()
    
    # Add conversation handler for the start command
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            0: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)]
        },
        fallbacks=[CommandHandler("cancel", cancel)]
    )
    
    # Add handlers
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.Regex("^ЁЯУЭ рдкрд░реАрдХреНрд╖рд╛ рд╕реБрд░реВ рдХрд░рд╛$"), start_exam))
    application.add_handler(MessageHandler(filters.Regex("^ЁЯУШ рд╡рд┐рд╖рдп рдирд┐рд╡рдбрд╛$"), 
                                         lambda update, context: update.message.reply_text(
                                             "рд╡рд┐рд╖рдп рдирд┐рд╡рдбрд╛:", reply_markup=subject_keyboard())))
    application.add_handler(MessageHandler(filters.Regex("^ЁЯТб рджреИрдирдВрджрд┐рди рд╡рд┐рдЪрд╛рд░$"), daily_thought))
    application.add_handler(MessageHandler(filters.Regex("^ЁЯУ░ рдмрд╛рддрдореНрдпрд╛$"), news_updates))
    application.add_handler(MessageHandler(filters.Regex("^тП░ рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХрд░рд╛$"), set_reminder))
    application.add_handler(MessageHandler(filters.Regex("^ЁЯХТ рд╡реЗрд│ рдЖрдгрд┐ рддрд╛рд░реАрдЦ$"), show_time_date))
    
    # Add callback query handlers
    application.add_handler(CallbackQueryHandler(select_subject, pattern="^subject_"))
    application.add_handler(CallbackQueryHandler(main_menu, pattern="^main_menu$"))
    application.add_handler(CallbackQueryHandler(handle_answer, pattern="^answer_"))
    application.add_handler(CallbackQueryHandler(exit_exam, pattern="^exit_exam$"))
    application.add_handler(CallbackQueryHandler(confirm_exit, pattern="^confirm_exit$"))
    application.add_handler(CallbackQueryHandler(cancel_exit, pattern="^cancel_exit$"))
    
    # Add conversation handler for setting reminders
    reminder_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^тП░ рд░рд┐рдорд╛рдЗрдВрдбрд░ рд╕реЗрдЯ рдХрд░рд╛$"), set_reminder)],
        states={
            SETTING_REMINDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reminder_input)]
        },
        fallbacks=[CommandHandler("cancel", cancel)]
    )
    application.add_handler(reminder_handler)
    
    # Add error handler
    application.add_error_handler(error_handler)
    
    # Start the Bot
    application.run_polling()

if __name__ == "__main__":
    main()